---
description: |
  Packer Plugins allow new functionality to be added to Packer without modifying
  the core source code. Packer plugins are able to add new builders,
  provisioners, hooks, data sources, and more.
page_title: Plugins
sidebar_title: Plugins
---

# Plugins

Packer Plugins allow new functionality to be added to Packer without modifying
the core source code. A single Packer plugin set is able to add builders,
provisioners, hooks, data sources, and more.

This section will cover how to install and use plugins. If you're interested in
developing plugins, the documentation for that is available below, in the
[developing plugins](#developing-plugins) section.

The current official listing of available Packer plugins can be found
[here](/community-tools#third-party-plugins). This is an incomplete list,
and more plugins can be found by searching. Typically, searching "packer plugin
_x_" will find what you're looking for if it exists. We hope to create an
offical registry for third party plugins in the future.

## How Plugins Work

Packer plugins are completely separate, standalone applications that the core
of Packer starts and communicates with.

These plugin applications aren't meant to be run manually. Instead, Packer core
executes them as a sub-process, run as a sub-command (`packer plugin`) and
communicates with them. For example, the Shell provisioner is actually run as
`packer plugin packer-provisioner-shell`. The next time you run a Packer build,
look at your process list and you should see a handful of `packer-` prefixed
applications running.

## Installing Plugins

The easiest way to install a plugin is to name it correctly, then place it in
the proper directory. To name a plugin correctly, make sure the binary is named
`packer-plugin-NAME`. For example, `packer-plugin-amazon` for a "plugin"
binary named "amazon". This binary will make one or more plugins
available to use. Valid types for plugins are down this page.

Once the plugin is named properly, Packer automatically discovers plugins in
the following directories in the given order. If a conflicting plugin is found
later, it will take precedence over one found earlier.

1.  The directory where `packer` is, or the executable directory.

2.  The `$HOME/.packer.d/plugins` directory, if `$HOME` is defined (unix)

3.  The `%APPDATA%/packer.d/plugins` if `%APPDATA%` is defined (windows)

4.  The `%USERPROFILE%/packer.d/plugins` if `%USERPROFILE%` is defined
    (windows)

5.  The current working directory.

6.  The directory defined in the env var `PACKER_PLUGIN_PATH`. There can be more
    than one directory defined; for example, `~/custom-dir-1:~/custom-dir-2`.
    Separate directories in the PATH string using a colon (`:`) on posix systems and
    a semicolon (`;`) on windows systems. The above example path would be able to
    find a provisioner named `packer-provisioner-foo` in either
    `~/custom-dir-1/packer-provisioner-foo` or
    `~/custom-dir-2/packer-provisioner-foo`.

The valid types for plugins are:

- `plugin` - A plugin binary that can contain one or more of each Packer plugin
  type.

- `builder` - Plugins responsible for building images for a specific
  platform.

- `post-processor` - A post-processor responsible for taking an artifact from
  a builder and turning it into something else.

- `provisioner` - A provisioner to install software on images created by a
  builder.

~> **Note**: Only _multi-plugin binaries_ -- that is plugins named
packer-plugin-*, like the `packer-plugin-amazon` described before -- are
expected to work with Packer's plugin manager. The legacy `builder`,
`post-processor` and `provisioner` plugin types will keep on being detected but
Packer cannot install them automatically.


## How to Develop Plugins

Plugins are written in Go, using the [Packer Plugin SDK](https://github.com/hashicorp/packer-plugin-sdk).
For more information on developing providers, see the [Extending Packer](/docs/extending) documentation.
