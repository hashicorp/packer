// Code generated by protoc-gen-go. DO NOT EDIT.
// source: yandex/cloud/compute/v1/disk_service.proto

package compute

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/yandex-cloud/go-genproto/yandex/cloud"
	_ "github.com/yandex-cloud/go-genproto/yandex/cloud/api"
	operation "github.com/yandex-cloud/go-genproto/yandex/cloud/operation"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetDiskRequest struct {
	// ID of the Disk resource to return.
	// To get the disk ID use a [DiskService.List] request.
	DiskId               string   `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDiskRequest) Reset()         { *m = GetDiskRequest{} }
func (m *GetDiskRequest) String() string { return proto.CompactTextString(m) }
func (*GetDiskRequest) ProtoMessage()    {}
func (*GetDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{0}
}

func (m *GetDiskRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDiskRequest.Unmarshal(m, b)
}
func (m *GetDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDiskRequest.Marshal(b, m, deterministic)
}
func (m *GetDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDiskRequest.Merge(m, src)
}
func (m *GetDiskRequest) XXX_Size() int {
	return xxx_messageInfo_GetDiskRequest.Size(m)
}
func (m *GetDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDiskRequest proto.InternalMessageInfo

func (m *GetDiskRequest) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

type ListDisksRequest struct {
	// ID of the folder to list disks in.
	// To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
	FolderId string `protobuf:"bytes,1,opt,name=folder_id,json=folderId,proto3" json:"folder_id,omitempty"`
	// The maximum number of results per page to return. If the number of available
	// results is larger than [page_size],
	// the service returns a [ListDisksResponse.next_page_token]
	// that can be used to get the next page of results in subsequent list requests.
	PageSize int64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Page token. To get the next page of results, set [page_token] to the
	// [ListDisksResponse.next_page_token] returned by a previous list request.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// A filter expression that filters resources listed in the response.
	// The expression must specify:
	// 1. The field name. Currently you can use filtering only on the [Disk.name] field.
	// 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
	// 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
	Filter               string   `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDisksRequest) Reset()         { *m = ListDisksRequest{} }
func (m *ListDisksRequest) String() string { return proto.CompactTextString(m) }
func (*ListDisksRequest) ProtoMessage()    {}
func (*ListDisksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{1}
}

func (m *ListDisksRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListDisksRequest.Unmarshal(m, b)
}
func (m *ListDisksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListDisksRequest.Marshal(b, m, deterministic)
}
func (m *ListDisksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDisksRequest.Merge(m, src)
}
func (m *ListDisksRequest) XXX_Size() int {
	return xxx_messageInfo_ListDisksRequest.Size(m)
}
func (m *ListDisksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDisksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDisksRequest proto.InternalMessageInfo

func (m *ListDisksRequest) GetFolderId() string {
	if m != nil {
		return m.FolderId
	}
	return ""
}

func (m *ListDisksRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListDisksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListDisksRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

type ListDisksResponse struct {
	// List of Disk resources.
	Disks []*Disk `protobuf:"bytes,1,rep,name=disks,proto3" json:"disks,omitempty"`
	// This token allows you to get the next page of results for list requests. If the number of results
	// is larger than [ListDisksRequest.page_size], use
	// the [next_page_token] as the value
	// for the [ListDisksRequest.page_token] query parameter
	// in the next list request. Each subsequent list request will have its own
	// [next_page_token] to continue paging through the results.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDisksResponse) Reset()         { *m = ListDisksResponse{} }
func (m *ListDisksResponse) String() string { return proto.CompactTextString(m) }
func (*ListDisksResponse) ProtoMessage()    {}
func (*ListDisksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{2}
}

func (m *ListDisksResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListDisksResponse.Unmarshal(m, b)
}
func (m *ListDisksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListDisksResponse.Marshal(b, m, deterministic)
}
func (m *ListDisksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDisksResponse.Merge(m, src)
}
func (m *ListDisksResponse) XXX_Size() int {
	return xxx_messageInfo_ListDisksResponse.Size(m)
}
func (m *ListDisksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDisksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDisksResponse proto.InternalMessageInfo

func (m *ListDisksResponse) GetDisks() []*Disk {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *ListDisksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateDiskRequest struct {
	// ID of the folder to create a disk in.
	// To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
	FolderId string `protobuf:"bytes,1,opt,name=folder_id,json=folderId,proto3" json:"folder_id,omitempty"`
	// Name of the disk.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the disk.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Resource labels as `key:value` pairs.
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ID of the disk type.
	// To get a list of available disk types use the [yandex.cloud.compute.v1.DiskTypeService.List] request.
	TypeId string `protobuf:"bytes,5,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	// ID of the availability zone where the disk resides.
	// To get a list of available zones use the [yandex.cloud.compute.v1.ZoneService.List] request.
	ZoneId string `protobuf:"bytes,6,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	// Size of the disk, specified in bytes.
	// If the disk was created from a image, this value should be more than the
	// [yandex.cloud.compute.v1.Image.min_disk_size] value.
	Size int64 `protobuf:"varint,7,opt,name=size,proto3" json:"size,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*CreateDiskRequest_ImageId
	//	*CreateDiskRequest_SnapshotId
	Source               isCreateDiskRequest_Source `protobuf_oneof:"source"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CreateDiskRequest) Reset()         { *m = CreateDiskRequest{} }
func (m *CreateDiskRequest) String() string { return proto.CompactTextString(m) }
func (*CreateDiskRequest) ProtoMessage()    {}
func (*CreateDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{3}
}

func (m *CreateDiskRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateDiskRequest.Unmarshal(m, b)
}
func (m *CreateDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateDiskRequest.Marshal(b, m, deterministic)
}
func (m *CreateDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDiskRequest.Merge(m, src)
}
func (m *CreateDiskRequest) XXX_Size() int {
	return xxx_messageInfo_CreateDiskRequest.Size(m)
}
func (m *CreateDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDiskRequest proto.InternalMessageInfo

func (m *CreateDiskRequest) GetFolderId() string {
	if m != nil {
		return m.FolderId
	}
	return ""
}

func (m *CreateDiskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateDiskRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateDiskRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *CreateDiskRequest) GetTypeId() string {
	if m != nil {
		return m.TypeId
	}
	return ""
}

func (m *CreateDiskRequest) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *CreateDiskRequest) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type isCreateDiskRequest_Source interface {
	isCreateDiskRequest_Source()
}

type CreateDiskRequest_ImageId struct {
	ImageId string `protobuf:"bytes,8,opt,name=image_id,json=imageId,proto3,oneof"`
}

type CreateDiskRequest_SnapshotId struct {
	SnapshotId string `protobuf:"bytes,9,opt,name=snapshot_id,json=snapshotId,proto3,oneof"`
}

func (*CreateDiskRequest_ImageId) isCreateDiskRequest_Source() {}

func (*CreateDiskRequest_SnapshotId) isCreateDiskRequest_Source() {}

func (m *CreateDiskRequest) GetSource() isCreateDiskRequest_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *CreateDiskRequest) GetImageId() string {
	if x, ok := m.GetSource().(*CreateDiskRequest_ImageId); ok {
		return x.ImageId
	}
	return ""
}

func (m *CreateDiskRequest) GetSnapshotId() string {
	if x, ok := m.GetSource().(*CreateDiskRequest_SnapshotId); ok {
		return x.SnapshotId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateDiskRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateDiskRequest_ImageId)(nil),
		(*CreateDiskRequest_SnapshotId)(nil),
	}
}

type CreateDiskMetadata struct {
	// ID of the disk that is being created.
	DiskId               string   `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDiskMetadata) Reset()         { *m = CreateDiskMetadata{} }
func (m *CreateDiskMetadata) String() string { return proto.CompactTextString(m) }
func (*CreateDiskMetadata) ProtoMessage()    {}
func (*CreateDiskMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{4}
}

func (m *CreateDiskMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateDiskMetadata.Unmarshal(m, b)
}
func (m *CreateDiskMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateDiskMetadata.Marshal(b, m, deterministic)
}
func (m *CreateDiskMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDiskMetadata.Merge(m, src)
}
func (m *CreateDiskMetadata) XXX_Size() int {
	return xxx_messageInfo_CreateDiskMetadata.Size(m)
}
func (m *CreateDiskMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDiskMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDiskMetadata proto.InternalMessageInfo

func (m *CreateDiskMetadata) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

type UpdateDiskRequest struct {
	// ID of the Disk resource to update.
	// To get the disk ID use a [DiskService.List] request.
	DiskId string `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	// Field mask that specifies which fields of the Disk resource are going to be updated.
	UpdateMask *field_mask.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	// Name of the disk.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the disk.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Resource labels as `key:value` pairs.
	//
	// Existing set of `labels` is completely replaced by the provided set.
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Size of the disk, specified in bytes.
	Size                 int64    `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDiskRequest) Reset()         { *m = UpdateDiskRequest{} }
func (m *UpdateDiskRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateDiskRequest) ProtoMessage()    {}
func (*UpdateDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{5}
}

func (m *UpdateDiskRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateDiskRequest.Unmarshal(m, b)
}
func (m *UpdateDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateDiskRequest.Marshal(b, m, deterministic)
}
func (m *UpdateDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDiskRequest.Merge(m, src)
}
func (m *UpdateDiskRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateDiskRequest.Size(m)
}
func (m *UpdateDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDiskRequest proto.InternalMessageInfo

func (m *UpdateDiskRequest) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

func (m *UpdateDiskRequest) GetUpdateMask() *field_mask.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

func (m *UpdateDiskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateDiskRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UpdateDiskRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *UpdateDiskRequest) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type UpdateDiskMetadata struct {
	// ID of the Disk resource that is being updated.
	DiskId               string   `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDiskMetadata) Reset()         { *m = UpdateDiskMetadata{} }
func (m *UpdateDiskMetadata) String() string { return proto.CompactTextString(m) }
func (*UpdateDiskMetadata) ProtoMessage()    {}
func (*UpdateDiskMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{6}
}

func (m *UpdateDiskMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateDiskMetadata.Unmarshal(m, b)
}
func (m *UpdateDiskMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateDiskMetadata.Marshal(b, m, deterministic)
}
func (m *UpdateDiskMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDiskMetadata.Merge(m, src)
}
func (m *UpdateDiskMetadata) XXX_Size() int {
	return xxx_messageInfo_UpdateDiskMetadata.Size(m)
}
func (m *UpdateDiskMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDiskMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDiskMetadata proto.InternalMessageInfo

func (m *UpdateDiskMetadata) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

type DeleteDiskRequest struct {
	// ID of the disk to delete.
	// To get the disk ID use a [DiskService.List] request.
	DiskId               string   `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDiskRequest) Reset()         { *m = DeleteDiskRequest{} }
func (m *DeleteDiskRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDiskRequest) ProtoMessage()    {}
func (*DeleteDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{7}
}

func (m *DeleteDiskRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteDiskRequest.Unmarshal(m, b)
}
func (m *DeleteDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteDiskRequest.Marshal(b, m, deterministic)
}
func (m *DeleteDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDiskRequest.Merge(m, src)
}
func (m *DeleteDiskRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteDiskRequest.Size(m)
}
func (m *DeleteDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDiskRequest proto.InternalMessageInfo

func (m *DeleteDiskRequest) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

type DeleteDiskMetadata struct {
	// ID of the disk that is being deleted.
	DiskId               string   `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDiskMetadata) Reset()         { *m = DeleteDiskMetadata{} }
func (m *DeleteDiskMetadata) String() string { return proto.CompactTextString(m) }
func (*DeleteDiskMetadata) ProtoMessage()    {}
func (*DeleteDiskMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{8}
}

func (m *DeleteDiskMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteDiskMetadata.Unmarshal(m, b)
}
func (m *DeleteDiskMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteDiskMetadata.Marshal(b, m, deterministic)
}
func (m *DeleteDiskMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDiskMetadata.Merge(m, src)
}
func (m *DeleteDiskMetadata) XXX_Size() int {
	return xxx_messageInfo_DeleteDiskMetadata.Size(m)
}
func (m *DeleteDiskMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDiskMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDiskMetadata proto.InternalMessageInfo

func (m *DeleteDiskMetadata) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

type ListDiskOperationsRequest struct {
	// ID of the Disk resource to list operations for.
	DiskId string `protobuf:"bytes,1,opt,name=disk_id,json=diskId,proto3" json:"disk_id,omitempty"`
	// The maximum number of results per page to return. If the number of available
	// results is larger than [page_size], the service returns a [ListDiskOperationsResponse.next_page_token]
	// that can be used to get the next page of results in subsequent list requests.
	PageSize int64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Page token. To get the next page of results, set [page_token] to the
	// [ListDiskOperationsResponse.next_page_token] returned by a previous list request.
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDiskOperationsRequest) Reset()         { *m = ListDiskOperationsRequest{} }
func (m *ListDiskOperationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListDiskOperationsRequest) ProtoMessage()    {}
func (*ListDiskOperationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{9}
}

func (m *ListDiskOperationsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListDiskOperationsRequest.Unmarshal(m, b)
}
func (m *ListDiskOperationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListDiskOperationsRequest.Marshal(b, m, deterministic)
}
func (m *ListDiskOperationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDiskOperationsRequest.Merge(m, src)
}
func (m *ListDiskOperationsRequest) XXX_Size() int {
	return xxx_messageInfo_ListDiskOperationsRequest.Size(m)
}
func (m *ListDiskOperationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDiskOperationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDiskOperationsRequest proto.InternalMessageInfo

func (m *ListDiskOperationsRequest) GetDiskId() string {
	if m != nil {
		return m.DiskId
	}
	return ""
}

func (m *ListDiskOperationsRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListDiskOperationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ListDiskOperationsResponse struct {
	// List of operations for the specified disk.
	Operations []*operation.Operation `protobuf:"bytes,1,rep,name=operations,proto3" json:"operations,omitempty"`
	// This token allows you to get the next page of results for list requests. If the number of results
	// is larger than [ListDiskOperationsRequest.page_size], use the [next_page_token] as the value
	// for the [ListDiskOperationsRequest.page_token] query parameter in the next list request.
	// Each subsequent list request will have its own [next_page_token] to continue paging through the results.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDiskOperationsResponse) Reset()         { *m = ListDiskOperationsResponse{} }
func (m *ListDiskOperationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListDiskOperationsResponse) ProtoMessage()    {}
func (*ListDiskOperationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7733692e1b0587d9, []int{10}
}

func (m *ListDiskOperationsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListDiskOperationsResponse.Unmarshal(m, b)
}
func (m *ListDiskOperationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListDiskOperationsResponse.Marshal(b, m, deterministic)
}
func (m *ListDiskOperationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDiskOperationsResponse.Merge(m, src)
}
func (m *ListDiskOperationsResponse) XXX_Size() int {
	return xxx_messageInfo_ListDiskOperationsResponse.Size(m)
}
func (m *ListDiskOperationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDiskOperationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDiskOperationsResponse proto.InternalMessageInfo

func (m *ListDiskOperationsResponse) GetOperations() []*operation.Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *ListDiskOperationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func init() {
	proto.RegisterType((*GetDiskRequest)(nil), "yandex.cloud.compute.v1.GetDiskRequest")
	proto.RegisterType((*ListDisksRequest)(nil), "yandex.cloud.compute.v1.ListDisksRequest")
	proto.RegisterType((*ListDisksResponse)(nil), "yandex.cloud.compute.v1.ListDisksResponse")
	proto.RegisterType((*CreateDiskRequest)(nil), "yandex.cloud.compute.v1.CreateDiskRequest")
	proto.RegisterMapType((map[string]string)(nil), "yandex.cloud.compute.v1.CreateDiskRequest.LabelsEntry")
	proto.RegisterType((*CreateDiskMetadata)(nil), "yandex.cloud.compute.v1.CreateDiskMetadata")
	proto.RegisterType((*UpdateDiskRequest)(nil), "yandex.cloud.compute.v1.UpdateDiskRequest")
	proto.RegisterMapType((map[string]string)(nil), "yandex.cloud.compute.v1.UpdateDiskRequest.LabelsEntry")
	proto.RegisterType((*UpdateDiskMetadata)(nil), "yandex.cloud.compute.v1.UpdateDiskMetadata")
	proto.RegisterType((*DeleteDiskRequest)(nil), "yandex.cloud.compute.v1.DeleteDiskRequest")
	proto.RegisterType((*DeleteDiskMetadata)(nil), "yandex.cloud.compute.v1.DeleteDiskMetadata")
	proto.RegisterType((*ListDiskOperationsRequest)(nil), "yandex.cloud.compute.v1.ListDiskOperationsRequest")
	proto.RegisterType((*ListDiskOperationsResponse)(nil), "yandex.cloud.compute.v1.ListDiskOperationsResponse")
}

func init() {
	proto.RegisterFile("yandex/cloud/compute/v1/disk_service.proto", fileDescriptor_7733692e1b0587d9)
}

var fileDescriptor_7733692e1b0587d9 = []byte{
	// 1084 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x73, 0xdb, 0x54,
	0x10, 0x47, 0xb1, 0xa2, 0xd8, 0x6b, 0x28, 0xc9, 0x83, 0x52, 0x47, 0x90, 0x99, 0x44, 0x4c, 0xd3,
	0xd4, 0x45, 0x92, 0x65, 0x3b, 0xa6, 0x49, 0xdb, 0x61, 0x70, 0x13, 0x8a, 0x67, 0xda, 0x81, 0x51,
	0xe1, 0x42, 0xa6, 0x93, 0x51, 0xac, 0x17, 0x57, 0x63, 0x59, 0x12, 0x7a, 0xb2, 0x27, 0x76, 0xe9,
	0xa5, 0x17, 0x66, 0xc2, 0x81, 0x43, 0x87, 0x23, 0x1f, 0x80, 0xe1, 0x96, 0xe1, 0x3b, 0x38, 0xc3,
	0xb1, 0x1c, 0xf8, 0x02, 0x1c, 0x38, 0xf7, 0xd8, 0x13, 0xf3, 0x9e, 0xe4, 0xff, 0x7f, 0x43, 0xe1,
	0x26, 0x69, 0x7f, 0xbb, 0xfa, 0xed, 0xbe, 0xdf, 0xee, 0x3e, 0x48, 0x37, 0x0d, 0xc7, 0xc4, 0x27,
	0x6a, 0xd9, 0x76, 0xeb, 0xa6, 0x5a, 0x76, 0x6b, 0x5e, 0x3d, 0xc0, 0x6a, 0x43, 0x53, 0x4d, 0x8b,
	0x54, 0x0f, 0x09, 0xf6, 0x1b, 0x56, 0x19, 0x2b, 0x9e, 0xef, 0x06, 0x2e, 0xba, 0x12, 0x62, 0x15,
	0x86, 0x55, 0x22, 0xac, 0xd2, 0xd0, 0xc4, 0x0f, 0x2a, 0xae, 0x5b, 0xb1, 0xb1, 0x6a, 0x78, 0x96,
	0x6a, 0x38, 0x8e, 0x1b, 0x18, 0x81, 0xe5, 0x3a, 0x24, 0x74, 0x13, 0xd7, 0x23, 0x2b, 0x7b, 0x3b,
	0xaa, 0x1f, 0xab, 0xc7, 0x16, 0xb6, 0xcd, 0xc3, 0x9a, 0x41, 0xaa, 0x1d, 0xc4, 0x00, 0x09, 0x1a,
	0xc5, 0xf5, 0xb0, 0xcf, 0x82, 0x44, 0x08, 0x69, 0x1a, 0xcd, 0x08, 0xb3, 0x39, 0x80, 0xe9, 0x46,
	0x18, 0x89, 0xb5, 0x36, 0x80, 0x6b, 0x18, 0xb6, 0x65, 0xf6, 0x99, 0xa5, 0x8f, 0xe1, 0xd2, 0x3d,
	0x1c, 0xec, 0x59, 0xa4, 0xaa, 0xe3, 0x6f, 0xeb, 0x98, 0x04, 0xe8, 0x2a, 0x2c, 0xb1, 0x6a, 0x58,
	0x66, 0x8a, 0x5b, 0xe7, 0xb6, 0x12, 0xc5, 0x37, 0xff, 0x6e, 0x6b, 0xdc, 0xe9, 0xb9, 0xc6, 0xdf,
	0xbe, 0xb3, 0x9d, 0xd1, 0x05, 0x6a, 0x2c, 0x99, 0xd2, 0x6f, 0x1c, 0x2c, 0xdf, 0xb7, 0x08, 0x73,
	0x25, 0x1d, 0xdf, 0xeb, 0x90, 0x38, 0x76, 0x6d, 0x13, 0xfb, 0x93, 0xbc, 0xe3, 0xa1, 0xb9, 0x64,
	0xa2, 0x6b, 0x90, 0xf0, 0x8c, 0x0a, 0x3e, 0x24, 0x56, 0x0b, 0xa7, 0x16, 0xd6, 0xb9, 0xad, 0x58,
	0x11, 0x5e, 0xb5, 0x35, 0xe1, 0xf6, 0x1d, 0x2d, 0x93, 0xc9, 0xe8, 0x71, 0x6a, 0x7c, 0x68, 0xb5,
	0x30, 0xda, 0x02, 0x60, 0xc0, 0xc0, 0xad, 0x62, 0x27, 0x15, 0x63, 0x41, 0x13, 0xa7, 0xe7, 0xda,
	0x22, 0x43, 0xea, 0x2c, 0xca, 0x57, 0xd4, 0x86, 0x24, 0x10, 0x8e, 0x2d, 0x3b, 0xc0, 0x7e, 0x8a,
	0x67, 0x28, 0x38, 0x3d, 0xef, 0xc6, 0x8b, 0x2c, 0x92, 0x07, 0x2b, 0x7d, 0xac, 0x89, 0xe7, 0x3a,
	0x04, 0xa3, 0x1c, 0x2c, 0xd2, 0xac, 0x48, 0x8a, 0x5b, 0x8f, 0x6d, 0x25, 0xb3, 0x6b, 0xca, 0x84,
	0xa3, 0x57, 0x58, 0x9d, 0x42, 0x2c, 0xda, 0x84, 0xb7, 0x1d, 0x7c, 0x12, 0x1c, 0xf6, 0x91, 0xa3,
	0x69, 0x24, 0xf4, 0xb7, 0xe8, 0xe7, 0x2f, 0x3b, 0xac, 0xa4, 0xdf, 0x79, 0x58, 0xb9, 0xeb, 0x63,
	0x23, 0xc0, 0xfd, 0x55, 0xbe, 0x40, 0xa5, 0xb6, 0x81, 0x77, 0x8c, 0x5a, 0x58, 0xa4, 0x44, 0x71,
	0xe3, 0x65, 0x5b, 0x5b, 0xfb, 0xee, 0xc0, 0x90, 0x5b, 0x8f, 0x0e, 0x64, 0x43, 0x6e, 0x65, 0xe4,
	0x9d, 0x47, 0x4f, 0xb4, 0x8f, 0x0a, 0xda, 0xd3, 0x83, 0xe8, 0x4d, 0x67, 0x70, 0x74, 0x03, 0x92,
	0x26, 0x26, 0x65, 0xdf, 0xf2, 0xe8, 0x71, 0x0f, 0x16, 0x2e, 0xbb, 0x5d, 0xd0, 0xfb, 0xad, 0xe8,
	0x47, 0x0e, 0x04, 0xdb, 0x38, 0xc2, 0x36, 0x49, 0xf1, 0xac, 0x06, 0x85, 0x89, 0x35, 0x18, 0xc9,
	0x45, 0xb9, 0xcf, 0x1c, 0xf7, 0x9d, 0xc0, 0x6f, 0x16, 0x3f, 0x79, 0xd9, 0xd6, 0x92, 0x07, 0xf2,
	0x61, 0x46, 0xde, 0xa1, 0x14, 0xd3, 0xcf, 0x58, 0x3e, 0x85, 0x7c, 0x98, 0x57, 0x21, 0x77, 0x76,
	0xae, 0x09, 0x22, 0xaf, 0xc9, 0xec, 0x09, 0xa1, 0xe5, 0x28, 0x91, 0x2e, 0x5e, 0x8f, 0x68, 0xa0,
	0x0d, 0x58, 0x0a, 0x9a, 0x1e, 0xa6, 0xe5, 0x59, 0x64, 0xd4, 0xe3, 0x3d, 0x09, 0x52, 0x43, 0xc9,
	0xa4, 0x4a, 0x6d, 0xb9, 0x0e, 0x83, 0x08, 0xe3, 0x94, 0x4a, 0x8d, 0x25, 0x13, 0x69, 0xc0, 0x33,
	0x91, 0x2d, 0x31, 0x91, 0xad, 0x51, 0xcc, 0xab, 0xb6, 0x76, 0x39, 0xaf, 0xed, 0xe4, 0x73, 0x99,
	0xbc, 0x9c, 0xcf, 0xed, 0xdc, 0xcc, 0xe4, 0x0b, 0xdb, 0x9a, 0xa6, 0x65, 0xf2, 0x3a, 0x83, 0xa2,
	0xab, 0x10, 0xb7, 0x6a, 0xf4, 0x5c, 0x2d, 0x33, 0x15, 0x1f, 0xfc, 0xfb, 0xe7, 0x6f, 0xe8, 0x4b,
	0xcc, 0x56, 0x32, 0x69, 0x89, 0x89, 0x63, 0x78, 0xe4, 0xb1, 0x1b, 0x50, 0x64, 0x62, 0x04, 0x09,
	0x1d, 0x73, 0xc9, 0x14, 0x77, 0x20, 0xd9, 0x57, 0x28, 0xb4, 0x0c, 0xb1, 0x2a, 0x6e, 0x86, 0x47,
	0xaf, 0xd3, 0x47, 0xf4, 0x2e, 0x2c, 0x36, 0x0c, 0xbb, 0x1e, 0x1d, 0xb4, 0x1e, 0xbe, 0xec, 0x2e,
	0xdc, 0xe4, 0x8a, 0x71, 0x10, 0x88, 0x5b, 0xf7, 0xcb, 0x58, 0x92, 0x01, 0xf5, 0xea, 0xff, 0x00,
	0x07, 0x86, 0x69, 0x04, 0x06, 0xba, 0x32, 0xd4, 0xb2, 0xdd, 0x26, 0xfd, 0x33, 0x06, 0x2b, 0x5f,
	0x7b, 0xe6, 0x90, 0xf6, 0xe6, 0xeb, 0x70, 0x74, 0x0b, 0x92, 0x75, 0xe6, 0xcb, 0x86, 0x17, 0x63,
	0x95, 0xcc, 0x8a, 0x4a, 0x38, 0xdf, 0x94, 0xce, 0x7c, 0x53, 0x3e, 0xa3, 0xf3, 0xed, 0x81, 0x41,
	0xaa, 0x3a, 0x84, 0x70, 0xfa, 0xdc, 0x15, 0x6d, 0xec, 0xb5, 0x44, 0xcb, 0xcf, 0x2b, 0xda, 0xc5,
	0x19, 0xa2, 0x1d, 0x29, 0xc2, 0xff, 0x23, 0x5a, 0x39, 0x92, 0x9a, 0xc0, 0xa4, 0xb6, 0x3a, 0x43,
	0x66, 0xaf, 0x21, 0x09, 0x2a, 0x84, 0x5e, 0x4e, 0xb3, 0x85, 0xb0, 0x0b, 0x2b, 0x7b, 0xd8, 0xc6,
	0xff, 0x46, 0x07, 0xf4, 0x57, 0x3d, 0xdf, 0xd9, 0xbf, 0xfa, 0x89, 0x83, 0xd5, 0xce, 0x88, 0xfd,
	0xa2, 0xb3, 0x8c, 0xc8, 0x05, 0xb5, 0xf7, 0xdf, 0x6f, 0x07, 0xe9, 0x7b, 0x0e, 0xc4, 0x71, 0xbc,
	0xa2, 0x1d, 0xf0, 0x29, 0x40, 0x77, 0x75, 0x76, 0x16, 0xc1, 0xc6, 0xa0, 0x9e, 0x7a, 0xab, 0xb5,
	0xeb, 0xaf, 0xf7, 0x39, 0xcd, 0xbb, 0x11, 0xb2, 0x3f, 0x2c, 0x41, 0x92, 0xb2, 0x78, 0x18, 0xde,
	0x37, 0x90, 0x0f, 0xb1, 0x7b, 0x38, 0x40, 0xd7, 0x26, 0xaa, 0x77, 0x70, 0x43, 0x8b, 0xd3, 0xf7,
	0x93, 0xf4, 0xe1, 0xb3, 0x3f, 0xfe, 0x7a, 0xbe, 0xb0, 0x86, 0xde, 0x1f, 0xbe, 0x39, 0x10, 0xf5,
	0x49, 0x54, 0xfb, 0xa7, 0xe8, 0x04, 0x78, 0x5a, 0x0c, 0x74, 0x7d, 0x62, 0xac, 0xe1, 0xe5, 0x2e,
	0xa6, 0xe7, 0x81, 0x86, 0xd5, 0x94, 0x56, 0x19, 0x87, 0x77, 0xd0, 0xca, 0x08, 0x07, 0xf4, 0x9c,
	0x03, 0x21, 0x9c, 0x61, 0x28, 0x3d, 0xff, 0x92, 0x11, 0x67, 0x9f, 0x85, 0xb4, 0x7b, 0xf6, 0x22,
	0x2d, 0x8e, 0x1d, 0x90, 0x3c, 0x7d, 0x63, 0x94, 0xde, 0x93, 0x46, 0x29, 0xed, 0x72, 0x69, 0xf4,
	0x33, 0x07, 0x42, 0xd8, 0x50, 0x53, 0x58, 0x8d, 0x4c, 0x91, 0x79, 0x58, 0xed, 0x85, 0xac, 0xc6,
	0x74, 0x6b, 0x8f, 0xd5, 0x7a, 0x76, 0xda, 0x61, 0x51, 0x7e, 0xbf, 0x72, 0x20, 0x84, 0x5d, 0x38,
	0x85, 0xdf, 0x48, 0x8b, 0xcf, 0xc3, 0x4f, 0x3f, 0x7b, 0x91, 0xbe, 0x31, 0xb6, 0xc5, 0x2f, 0x0f,
	0x8f, 0xfa, 0xfd, 0x9a, 0x17, 0x34, 0x43, 0x75, 0xa5, 0xa7, 0xaa, 0xeb, 0x17, 0x0e, 0x2e, 0x51,
	0x51, 0xf4, 0xfa, 0x0c, 0x65, 0x67, 0xaa, 0x67, 0x64, 0x58, 0x88, 0xb9, 0x0b, 0xf9, 0x44, 0xd2,
	0x53, 0x18, 0xc1, 0x2d, 0xb4, 0x39, 0x85, 0x60, 0xef, 0x96, 0x4c, 0x8a, 0xfb, 0xdf, 0xdc, 0xad,
	0x58, 0xc1, 0xe3, 0xfa, 0x11, 0x8d, 0xaf, 0x86, 0x3f, 0x94, 0xc3, 0xdb, 0x72, 0xc5, 0x95, 0x2b,
	0xd8, 0x61, 0xe9, 0xab, 0x13, 0xae, 0xe4, 0xb7, 0xa2, 0xc7, 0x23, 0x81, 0xc1, 0x72, 0xff, 0x04,
	0x00, 0x00, 0xff, 0xff, 0x53, 0xd3, 0x66, 0xe5, 0x63, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DiskServiceClient is the client API for DiskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DiskServiceClient interface {
	// Returns the specified Disk resource.
	//
	// To get the list of available Disk resources, make a [List] request.
	Get(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*Disk, error)
	// Retrieves the list of Disk resources in the specified folder.
	List(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*ListDisksResponse, error)
	// Creates a disk in the specified folder.
	//
	// You can create an empty disk or restore it from a snapshot or an image.
	// Method starts an asynchronous operation that can be cancelled while it is in progress.
	Create(ctx context.Context, in *CreateDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error)
	// Updates the specified disk.
	Update(ctx context.Context, in *UpdateDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error)
	// Deletes the specified disk.
	//
	// Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete
	// any snapshots or images previously made from the disk. You must delete snapshots and images separately.
	//
	// It is not possible to delete a disk that is attached to an instance.
	Delete(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error)
	// Lists operations for the specified disk.
	ListOperations(ctx context.Context, in *ListDiskOperationsRequest, opts ...grpc.CallOption) (*ListDiskOperationsResponse, error)
}

type diskServiceClient struct {
	cc *grpc.ClientConn
}

func NewDiskServiceClient(cc *grpc.ClientConn) DiskServiceClient {
	return &diskServiceClient{cc}
}

func (c *diskServiceClient) Get(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*Disk, error) {
	out := new(Disk)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskServiceClient) List(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*ListDisksResponse, error) {
	out := new(ListDisksResponse)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskServiceClient) Create(ctx context.Context, in *CreateDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error) {
	out := new(operation.Operation)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskServiceClient) Update(ctx context.Context, in *UpdateDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error) {
	out := new(operation.Operation)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskServiceClient) Delete(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*operation.Operation, error) {
	out := new(operation.Operation)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskServiceClient) ListOperations(ctx context.Context, in *ListDiskOperationsRequest, opts ...grpc.CallOption) (*ListDiskOperationsResponse, error) {
	out := new(ListDiskOperationsResponse)
	err := c.cc.Invoke(ctx, "/yandex.cloud.compute.v1.DiskService/ListOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiskServiceServer is the server API for DiskService service.
type DiskServiceServer interface {
	// Returns the specified Disk resource.
	//
	// To get the list of available Disk resources, make a [List] request.
	Get(context.Context, *GetDiskRequest) (*Disk, error)
	// Retrieves the list of Disk resources in the specified folder.
	List(context.Context, *ListDisksRequest) (*ListDisksResponse, error)
	// Creates a disk in the specified folder.
	//
	// You can create an empty disk or restore it from a snapshot or an image.
	// Method starts an asynchronous operation that can be cancelled while it is in progress.
	Create(context.Context, *CreateDiskRequest) (*operation.Operation, error)
	// Updates the specified disk.
	Update(context.Context, *UpdateDiskRequest) (*operation.Operation, error)
	// Deletes the specified disk.
	//
	// Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete
	// any snapshots or images previously made from the disk. You must delete snapshots and images separately.
	//
	// It is not possible to delete a disk that is attached to an instance.
	Delete(context.Context, *DeleteDiskRequest) (*operation.Operation, error)
	// Lists operations for the specified disk.
	ListOperations(context.Context, *ListDiskOperationsRequest) (*ListDiskOperationsResponse, error)
}

// UnimplementedDiskServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDiskServiceServer struct {
}

func (*UnimplementedDiskServiceServer) Get(ctx context.Context, req *GetDiskRequest) (*Disk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedDiskServiceServer) List(ctx context.Context, req *ListDisksRequest) (*ListDisksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedDiskServiceServer) Create(ctx context.Context, req *CreateDiskRequest) (*operation.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedDiskServiceServer) Update(ctx context.Context, req *UpdateDiskRequest) (*operation.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedDiskServiceServer) Delete(ctx context.Context, req *DeleteDiskRequest) (*operation.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedDiskServiceServer) ListOperations(ctx context.Context, req *ListDiskOperationsRequest) (*ListDiskOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOperations not implemented")
}

func RegisterDiskServiceServer(s *grpc.Server, srv DiskServiceServer) {
	s.RegisterService(&_DiskService_serviceDesc, srv)
}

func _DiskService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).Get(ctx, req.(*GetDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).List(ctx, req.(*ListDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).Create(ctx, req.(*CreateDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).Update(ctx, req.(*UpdateDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).Delete(ctx, req.(*DeleteDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskService_ListOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiskOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskServiceServer).ListOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yandex.cloud.compute.v1.DiskService/ListOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskServiceServer).ListOperations(ctx, req.(*ListDiskOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DiskService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "yandex.cloud.compute.v1.DiskService",
	HandlerType: (*DiskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _DiskService_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DiskService_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _DiskService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DiskService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DiskService_Delete_Handler,
		},
		{
			MethodName: "ListOperations",
			Handler:    _DiskService_ListOperations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "yandex/cloud/compute/v1/disk_service.proto",
}
