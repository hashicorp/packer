// Code generated by protoc-gen-go. DO NOT EDIT.
// source: yandex/cloud/compute/v1/disk.proto

package compute // import "github.com/yandex-cloud/go-genproto/yandex/cloud/compute/v1"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Disk_Status int32

const (
	Disk_STATUS_UNSPECIFIED Disk_Status = 0
	// Disk is being created.
	Disk_CREATING Disk_Status = 1
	// Disk is ready to use.
	Disk_READY Disk_Status = 2
	// Disk encountered a problem and cannot operate.
	Disk_ERROR Disk_Status = 3
	// Disk is being deleted.
	Disk_DELETING Disk_Status = 4
)

var Disk_Status_name = map[int32]string{
	0: "STATUS_UNSPECIFIED",
	1: "CREATING",
	2: "READY",
	3: "ERROR",
	4: "DELETING",
}
var Disk_Status_value = map[string]int32{
	"STATUS_UNSPECIFIED": 0,
	"CREATING":           1,
	"READY":              2,
	"ERROR":              3,
	"DELETING":           4,
}

func (x Disk_Status) String() string {
	return proto.EnumName(Disk_Status_name, int32(x))
}
func (Disk_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_disk_d27a2bc800477bf5, []int{0, 0}
}

// A Disk resource. For more information, see [Disks](/docs/compute/concepts/disk).
type Disk struct {
	// ID of the disk.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the folder that the disk belongs to.
	FolderId string `protobuf:"bytes,2,opt,name=folder_id,json=folderId,proto3" json:"folder_id,omitempty"`
	// Creation timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	CreatedAt *timestamp.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Name of the disk. 1-63 characters long.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the disk. 0-256 characters long.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Resource labels as `` key:value `` pairs. Maximum of 64 per resource.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ID of the disk type.
	TypeId string `protobuf:"bytes,7,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	// ID of the availability zone where the disk resides.
	ZoneId string `protobuf:"bytes,8,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	// Size of the disk, specified in bytes.
	Size int64 `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	// License IDs that indicate which licenses are attached to this resource.
	// License IDs are used to calculate additional charges for the use of the virtual machine.
	//
	// The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
	//
	// If you know the license IDs, specify them when you create the image.
	// For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
	// You can specify them in the [yandex.cloud.compute.v1.ImageService.Create] request.
	ProductIds []string `protobuf:"bytes,10,rep,name=product_ids,json=productIds,proto3" json:"product_ids,omitempty"`
	// Current status of the disk.
	Status Disk_Status `protobuf:"varint,11,opt,name=status,proto3,enum=yandex.cloud.compute.v1.Disk_Status" json:"status,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*Disk_SourceImageId
	//	*Disk_SourceSnapshotId
	Source isDisk_Source `protobuf_oneof:"source"`
	// Array of instances to which the disk is attached.
	InstanceIds          []string `protobuf:"bytes,14,rep,name=instance_ids,json=instanceIds,proto3" json:"instance_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Disk) Reset()         { *m = Disk{} }
func (m *Disk) String() string { return proto.CompactTextString(m) }
func (*Disk) ProtoMessage()    {}
func (*Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_disk_d27a2bc800477bf5, []int{0}
}
func (m *Disk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Disk.Unmarshal(m, b)
}
func (m *Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Disk.Marshal(b, m, deterministic)
}
func (dst *Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disk.Merge(dst, src)
}
func (m *Disk) XXX_Size() int {
	return xxx_messageInfo_Disk.Size(m)
}
func (m *Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_Disk proto.InternalMessageInfo

func (m *Disk) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Disk) GetFolderId() string {
	if m != nil {
		return m.FolderId
	}
	return ""
}

func (m *Disk) GetCreatedAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Disk) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Disk) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Disk) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Disk) GetTypeId() string {
	if m != nil {
		return m.TypeId
	}
	return ""
}

func (m *Disk) GetZoneId() string {
	if m != nil {
		return m.ZoneId
	}
	return ""
}

func (m *Disk) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Disk) GetProductIds() []string {
	if m != nil {
		return m.ProductIds
	}
	return nil
}

func (m *Disk) GetStatus() Disk_Status {
	if m != nil {
		return m.Status
	}
	return Disk_STATUS_UNSPECIFIED
}

type isDisk_Source interface {
	isDisk_Source()
}

type Disk_SourceImageId struct {
	SourceImageId string `protobuf:"bytes,12,opt,name=source_image_id,json=sourceImageId,proto3,oneof"`
}

type Disk_SourceSnapshotId struct {
	SourceSnapshotId string `protobuf:"bytes,13,opt,name=source_snapshot_id,json=sourceSnapshotId,proto3,oneof"`
}

func (*Disk_SourceImageId) isDisk_Source() {}

func (*Disk_SourceSnapshotId) isDisk_Source() {}

func (m *Disk) GetSource() isDisk_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Disk) GetSourceImageId() string {
	if x, ok := m.GetSource().(*Disk_SourceImageId); ok {
		return x.SourceImageId
	}
	return ""
}

func (m *Disk) GetSourceSnapshotId() string {
	if x, ok := m.GetSource().(*Disk_SourceSnapshotId); ok {
		return x.SourceSnapshotId
	}
	return ""
}

func (m *Disk) GetInstanceIds() []string {
	if m != nil {
		return m.InstanceIds
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Disk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Disk_OneofMarshaler, _Disk_OneofUnmarshaler, _Disk_OneofSizer, []interface{}{
		(*Disk_SourceImageId)(nil),
		(*Disk_SourceSnapshotId)(nil),
	}
}

func _Disk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Disk)
	// source
	switch x := m.Source.(type) {
	case *Disk_SourceImageId:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SourceImageId)
	case *Disk_SourceSnapshotId:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SourceSnapshotId)
	case nil:
	default:
		return fmt.Errorf("Disk.Source has unexpected type %T", x)
	}
	return nil
}

func _Disk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Disk)
	switch tag {
	case 12: // source.source_image_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Source = &Disk_SourceImageId{x}
		return true, err
	case 13: // source.source_snapshot_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Source = &Disk_SourceSnapshotId{x}
		return true, err
	default:
		return false, nil
	}
}

func _Disk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Disk)
	// source
	switch x := m.Source.(type) {
	case *Disk_SourceImageId:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.SourceImageId)))
		n += len(x.SourceImageId)
	case *Disk_SourceSnapshotId:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.SourceSnapshotId)))
		n += len(x.SourceSnapshotId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Disk)(nil), "yandex.cloud.compute.v1.Disk")
	proto.RegisterMapType((map[string]string)(nil), "yandex.cloud.compute.v1.Disk.LabelsEntry")
	proto.RegisterEnum("yandex.cloud.compute.v1.Disk_Status", Disk_Status_name, Disk_Status_value)
}

func init() {
	proto.RegisterFile("yandex/cloud/compute/v1/disk.proto", fileDescriptor_disk_d27a2bc800477bf5)
}

var fileDescriptor_disk_d27a2bc800477bf5 = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0x41, 0x4f, 0xdb, 0x3e,
	0x18, 0xc6, 0x49, 0xd3, 0x86, 0xe6, 0x0d, 0xf0, 0x8f, 0xac, 0xbf, 0x46, 0xc4, 0x0e, 0x64, 0x68,
	0x87, 0xec, 0x40, 0x22, 0xd8, 0x65, 0x6c, 0xbb, 0x14, 0x9a, 0x6d, 0x91, 0x10, 0x9b, 0xdc, 0x72,
	0xd8, 0x2e, 0x55, 0x1a, 0x9b, 0x60, 0x35, 0x8d, 0xa3, 0xd8, 0xa9, 0x56, 0x3e, 0xce, 0x3e, 0xe9,
	0x64, 0x3b, 0x95, 0xb8, 0xb0, 0xdb, 0xeb, 0xe7, 0xf9, 0xd9, 0xef, 0xf3, 0x5a, 0x36, 0x9c, 0x6d,
	0xf3, 0x9a, 0xd0, 0xdf, 0x49, 0x51, 0xf1, 0x8e, 0x24, 0x05, 0x5f, 0x37, 0x9d, 0xa4, 0xc9, 0xe6,
	0x22, 0x21, 0x4c, 0xac, 0xe2, 0xa6, 0xe5, 0x92, 0xa3, 0x63, 0xc3, 0xc4, 0x9a, 0x89, 0x7b, 0x26,
	0xde, 0x5c, 0x9c, 0x9c, 0x96, 0x9c, 0x97, 0x15, 0x4d, 0x34, 0xb6, 0xec, 0x1e, 0x12, 0xc9, 0xd6,
	0x54, 0xc8, 0x7c, 0xdd, 0x98, 0x9d, 0x67, 0x7f, 0x46, 0x30, 0x9c, 0x32, 0xb1, 0x42, 0x47, 0x30,
	0x60, 0x24, 0xb0, 0x42, 0x2b, 0x72, 0xf1, 0x80, 0x11, 0xf4, 0x1a, 0xdc, 0x07, 0x5e, 0x11, 0xda,
	0x2e, 0x18, 0x09, 0x06, 0x5a, 0x1e, 0x1b, 0x21, 0x23, 0xe8, 0x0a, 0xa0, 0x68, 0x69, 0x2e, 0x29,
	0x59, 0xe4, 0x32, 0xb0, 0x43, 0x2b, 0xf2, 0x2e, 0x4f, 0x62, 0xd3, 0x2b, 0xde, 0xf5, 0x8a, 0xe7,
	0xbb, 0x5e, 0xd8, 0xed, 0xe9, 0x89, 0x44, 0x08, 0x86, 0x75, 0xbe, 0xa6, 0xc1, 0x50, 0x1f, 0xa9,
	0x6b, 0x14, 0x82, 0x47, 0xa8, 0x28, 0x5a, 0xd6, 0x48, 0xc6, 0xeb, 0x60, 0xa4, 0xad, 0xe7, 0x12,
	0x9a, 0x80, 0x53, 0xe5, 0x4b, 0x5a, 0x89, 0xc0, 0x09, 0xed, 0xc8, 0xbb, 0x7c, 0x17, 0xbf, 0x30,
	0x71, 0xac, 0x86, 0x89, 0x6f, 0x35, 0x9b, 0xd6, 0xb2, 0xdd, 0xe2, 0x7e, 0x23, 0x3a, 0x86, 0x7d,
	0xb9, 0x6d, 0xa8, 0x1a, 0x67, 0x5f, 0x37, 0x70, 0xd4, 0x32, 0x23, 0xca, 0x78, 0xe2, 0xb5, 0x36,
	0xc6, 0xc6, 0x50, 0xcb, 0x8c, 0xa8, 0xa8, 0x82, 0x3d, 0xd1, 0xc0, 0x0d, 0xad, 0xc8, 0xc6, 0xba,
	0x46, 0xa7, 0xe0, 0x35, 0x2d, 0x27, 0x5d, 0x21, 0x17, 0x8c, 0x88, 0x00, 0x42, 0x3b, 0x72, 0x31,
	0xf4, 0x52, 0x46, 0x04, 0xfa, 0x0c, 0x8e, 0x90, 0xb9, 0xec, 0x44, 0xe0, 0x85, 0x56, 0x74, 0x74,
	0xf9, 0xf6, 0xdf, 0x49, 0x67, 0x9a, 0xc5, 0xfd, 0x1e, 0x14, 0xc1, 0x7f, 0x82, 0x77, 0x6d, 0x41,
	0x17, 0x6c, 0x9d, 0x97, 0x3a, 0xd3, 0x81, 0xca, 0xf4, 0x6d, 0x0f, 0x1f, 0x1a, 0x23, 0x53, 0x7a,
	0x46, 0x50, 0x0c, 0xa8, 0x27, 0x45, 0x9d, 0x37, 0xe2, 0x91, 0xab, 0x40, 0xc1, 0x61, 0x0f, 0xfb,
	0xc6, 0x9b, 0xf5, 0x56, 0x46, 0xd0, 0x1b, 0x38, 0x60, 0xb5, 0x90, 0x79, 0xad, 0xce, 0x26, 0x22,
	0x38, 0xd2, 0xc9, 0xbd, 0x9d, 0x96, 0x11, 0x71, 0x72, 0x05, 0xde, 0xb3, 0x8b, 0x43, 0x3e, 0xd8,
	0x2b, 0xba, 0xed, 0x9f, 0x84, 0x2a, 0xd1, 0xff, 0x30, 0xda, 0xe4, 0x55, 0x47, 0xfb, 0xf7, 0x60,
	0x16, 0x1f, 0x07, 0x1f, 0xac, 0x33, 0x0c, 0x8e, 0x99, 0x04, 0xbd, 0x02, 0x34, 0x9b, 0x4f, 0xe6,
	0xf7, 0xb3, 0xc5, 0xfd, 0xdd, 0xec, 0x47, 0x7a, 0x93, 0x7d, 0xc9, 0xd2, 0xa9, 0xbf, 0x87, 0x0e,
	0x60, 0x7c, 0x83, 0xd3, 0xc9, 0x3c, 0xbb, 0xfb, 0xea, 0x5b, 0xc8, 0x85, 0x11, 0x4e, 0x27, 0xd3,
	0x9f, 0xfe, 0x40, 0x95, 0x29, 0xc6, 0xdf, 0xb1, 0x6f, 0x2b, 0x66, 0x9a, 0xde, 0xa6, 0x9a, 0x19,
	0x5e, 0x8f, 0xc1, 0x31, 0x53, 0x5c, 0xa7, 0xbf, 0x6e, 0x4a, 0x26, 0x1f, 0xbb, 0xa5, 0xba, 0xbe,
	0xc4, 0xdc, 0xe7, 0xb9, 0xf9, 0x0f, 0x25, 0x3f, 0x2f, 0x69, 0xad, 0x9f, 0x5c, 0xf2, 0xc2, 0x47,
	0xf9, 0xd4, 0x97, 0x4b, 0x47, 0x63, 0xef, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x9d, 0xe9, 0x4b,
	0xc4, 0x52, 0x03, 0x00, 0x00,
}
